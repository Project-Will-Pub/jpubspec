package xyz.rk0cc.willpub.pubspec.data.dependencies.type;

import xyz.rk0cc.willpub.exceptions.pubspec.IllegalPubPackageNamingException;
import xyz.rk0cc.willpub.pubspec.data.PubspecValueValidator;

import javax.annotation.Nonnull;
import java.io.Serializable;
import java.util.Objects;

/**
 * Indicating the reference uses for importing {@link #name() related dependency}.
 *
 * @since 1.0.0
 */
@SuppressWarnings("JavaDoc")
public sealed abstract class DependencyReference implements Serializable
        permits GitReference, HostedReference, LocalReference, SDKReference, ThirdPartyHostedReference {
    private final String name;

    /**
     * Create general information of this dependency.
     *
     * @param name Dependency name.
     *
     * @throws IllegalPubPackageNamingException If dependency name is not follow naming standard.
     */
    DependencyReference(@Nonnull String name) throws IllegalPubPackageNamingException {
        PubspecValueValidator.ValueAssertion.assertPackageNaming(name);
        this.name = name;
    }

    /**
     * A dependency name which will be imported to {@link xyz.rk0cc.willpub.pubspec.data.Pubspec}.
     *
     * @return A package name.
     */
    public final String name() {
        return name;
    }

    /**
     * Check another object of {@link DependencyReference} has the same type and data inside.
     *
     * @param o Object of {@link DependencyReference} using to compare.
     *
     * @return <code>true</code> if both contains exact same data.
     */
    @Override
    public abstract boolean equals(Object o);

    /**
     * Hash code of {@link DependencyReference} which generated by {@link Objects#hash(Object...)}.
     * <br/>
     * It's usually hashes all unique object given from subclasses and add {@link DependencyReference#hashCode()}
     * which is a hashes {@link #name()}.
     *
     * @return A calculated hashcode of current reference.
     */
    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    /**
     * Describe entire {@link DependencyReference} displayed when called {@link java.io.PrintStream#print(Object)},
     * {@link Throwable#getMessage()} or handle it as a {@link String}.
     *
     * @return A {@link String} wrapping all information of this object.
     */
    @Override
    public abstract String toString();

    /**
     * A handler to edit any additional data field and throw {@link AssertionError} if caught
     * {@link IllegalPubPackageNamingException} as {@link #name()} can not be changed.
     *
     * @param modifier A modifier to apply modification.
     * @param <D> Subclasses of {@link DependencyReference}.
     *
     * @return New {@link D} object with modified field.
     */
    static <D extends DependencyReference> D modifyHandler(@Nonnull DependencyModifyFunction<D> modifier) {
        try {
            return modifier.updated();
        } catch (IllegalPubPackageNamingException e) {
            throw new AssertionError("False positive illegal package name caught.", e);
        }
    }

    /**
     * An interface for {@link #modifyHandler(DependencyModifyFunction)} that allowing to modify field without wrapping
     * try-catch block for catching {@link IllegalPubPackageNamingException} when applying modified field to new
     * {@link DependencyReference}.
     *
     * @param <D> Subclass of {@link DependencyReference}.
     */
    @FunctionalInterface
    interface DependencyModifyFunction<D extends DependencyReference> {
        D updated() throws IllegalPubPackageNamingException;
    }
}
